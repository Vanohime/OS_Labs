
Поведенческие шаблоны - это паттерны проектирования, которые описывают способы взаимодействия объектов и классов.


## 1. Шаблон Команда

**Проблема:**  
Нужно сделать отправителя и получателя комманды независимыми друг от друга напрямую.

**Решение:**  
Инкапсуляция запроса в объект с методом `execute()`.

**Примеры:**
1. Кнопки GUI, например в Swing.
2. Транзакции, например в СУБД
3. Undo/Redo в редакторах

**Многопоточность:**  
Многопоточность создает некоторые проблемы при использования шаблона Команда. Первое, что приходит в голову - взаимное исключение и требующаяся из-за него синхронизация.


## 2. Шаблон Стратегия 

**Проблема:**  
Есть семейство похожил алгоритмов, решающих также похожие задачи. Необходимо обобщить их, чтобы не увеличивать код основного класса при добавлении/изменении алгоритмов.

**Решение:**  
Инкапсуляция всех алгоритмов в классы, реализующие общий интерфейс.

**Примеры:**
1. Алгоритмы сортировки, например в стандартной библиотеке любого ЯП
2. Постоение маршрута в навигаторах (для пешехода, автомобиля итд) 
3. Поведение ИИ в играх

**Многопоточность:**  
Не могу придумать, как многопоточность может влиять на применение этого шаблона. 

## 3. Шаблонный метод

**Проблема:**  
Нужно определить алгоритм так, чтобы наследники могли менять некоторые его шаги.

**Решение:**  
Представим алгоритм как абстрактный класс со скелетом и набором методов с реализацией каждого шага.

**Примеры:**
1. Шаги подключения к разным БД
2. Рабоат программы с различными ОС.
3. Импорт/экспорт данных

**Многопоточность:**  
Наличие многопоточности потребует от абстрактного класса выполнять синхронизацию для того, чтобы гарантировать выполнение шагов алгоритма в нужном порядке.


Архитектура ПО — совокупность важнейших решений об организации программной системы.

## Влияние многопоточности на архитектуру
На примере 4 лабы я понял, что многопоточность просто обязывает программиста следовать принципу "разделяй и властвуй". Если однопоточную программу 

еще можно сделать в виде огромной функции main и кое-как покрыть тестами, то при нескольких потоках без разбивания кода на модули тестиовать невозмжно ничего в принципе.

Да и в контексте обычной разработки, поиск ошибок в многопоточном коде будет сильно затруднен, если каждый поток организован как монолит.



